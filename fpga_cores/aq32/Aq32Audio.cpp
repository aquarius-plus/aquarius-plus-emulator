#include "Aq32Audio.h"
#include "imgui.h"

enum {
    EG_ATTACK = 0,
    EG_DECAY,
    EG_SUSTAIN,
    EG_RELEASE
};

static const uint16_t lut_logsin[256] = {
    0x859, 0x6c3, 0x607, 0x58b, 0x52e, 0x4e4, 0x4a6, 0x471,
    0x443, 0x41a, 0x3f5, 0x3d3, 0x3b5, 0x398, 0x37e, 0x365,
    0x34e, 0x339, 0x324, 0x311, 0x2ff, 0x2ed, 0x2dc, 0x2cd,
    0x2bd, 0x2af, 0x2a0, 0x293, 0x286, 0x279, 0x26d, 0x261,
    0x256, 0x24b, 0x240, 0x236, 0x22c, 0x222, 0x218, 0x20f,
    0x206, 0x1fd, 0x1f5, 0x1ec, 0x1e4, 0x1dc, 0x1d4, 0x1cd,
    0x1c5, 0x1be, 0x1b7, 0x1b0, 0x1a9, 0x1a2, 0x19b, 0x195,
    0x18f, 0x188, 0x182, 0x17c, 0x177, 0x171, 0x16b, 0x166,
    0x160, 0x15b, 0x155, 0x150, 0x14b, 0x146, 0x141, 0x13c,
    0x137, 0x133, 0x12e, 0x129, 0x125, 0x121, 0x11c, 0x118,
    0x114, 0x10f, 0x10b, 0x107, 0x103, 0x0ff, 0x0fb, 0x0f8,
    0x0f4, 0x0f0, 0x0ec, 0x0e9, 0x0e5, 0x0e2, 0x0de, 0x0db,
    0x0d7, 0x0d4, 0x0d1, 0x0cd, 0x0ca, 0x0c7, 0x0c4, 0x0c1,
    0x0be, 0x0bb, 0x0b8, 0x0b5, 0x0b2, 0x0af, 0x0ac, 0x0a9,
    0x0a7, 0x0a4, 0x0a1, 0x09f, 0x09c, 0x099, 0x097, 0x094,
    0x092, 0x08f, 0x08d, 0x08a, 0x088, 0x086, 0x083, 0x081,
    0x07f, 0x07d, 0x07a, 0x078, 0x076, 0x074, 0x072, 0x070,
    0x06e, 0x06c, 0x06a, 0x068, 0x066, 0x064, 0x062, 0x060,
    0x05e, 0x05c, 0x05b, 0x059, 0x057, 0x055, 0x053, 0x052,
    0x050, 0x04e, 0x04d, 0x04b, 0x04a, 0x048, 0x046, 0x045,
    0x043, 0x042, 0x040, 0x03f, 0x03e, 0x03c, 0x03b, 0x039,
    0x038, 0x037, 0x035, 0x034, 0x033, 0x031, 0x030, 0x02f,
    0x02e, 0x02d, 0x02b, 0x02a, 0x029, 0x028, 0x027, 0x026,
    0x025, 0x024, 0x023, 0x022, 0x021, 0x020, 0x01f, 0x01e,
    0x01d, 0x01c, 0x01b, 0x01a, 0x019, 0x018, 0x017, 0x017,
    0x016, 0x015, 0x014, 0x014, 0x013, 0x012, 0x011, 0x011,
    0x010, 0x00f, 0x00f, 0x00e, 0x00d, 0x00d, 0x00c, 0x00c,
    0x00b, 0x00a, 0x00a, 0x009, 0x009, 0x008, 0x008, 0x007,
    0x007, 0x007, 0x006, 0x006, 0x005, 0x005, 0x005, 0x004,
    0x004, 0x004, 0x003, 0x003, 0x003, 0x002, 0x002, 0x002,
    0x002, 0x001, 0x001, 0x001, 0x001, 0x001, 0x001, 0x001,
    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000};

static const uint16_t lut_exp[256] = {
    0x3fa, 0x3f5, 0x3ef, 0x3ea, 0x3e4, 0x3df, 0x3da, 0x3d4,
    0x3cf, 0x3c9, 0x3c4, 0x3bf, 0x3b9, 0x3b4, 0x3ae, 0x3a9,
    0x3a4, 0x39f, 0x399, 0x394, 0x38f, 0x38a, 0x384, 0x37f,
    0x37a, 0x375, 0x370, 0x36a, 0x365, 0x360, 0x35b, 0x356,
    0x351, 0x34c, 0x347, 0x342, 0x33d, 0x338, 0x333, 0x32e,
    0x329, 0x324, 0x31f, 0x31a, 0x315, 0x310, 0x30b, 0x306,
    0x302, 0x2fd, 0x2f8, 0x2f3, 0x2ee, 0x2e9, 0x2e5, 0x2e0,
    0x2db, 0x2d6, 0x2d2, 0x2cd, 0x2c8, 0x2c4, 0x2bf, 0x2ba,
    0x2b5, 0x2b1, 0x2ac, 0x2a8, 0x2a3, 0x29e, 0x29a, 0x295,
    0x291, 0x28c, 0x288, 0x283, 0x27f, 0x27a, 0x276, 0x271,
    0x26d, 0x268, 0x264, 0x25f, 0x25b, 0x257, 0x252, 0x24e,
    0x249, 0x245, 0x241, 0x23c, 0x238, 0x234, 0x230, 0x22b,
    0x227, 0x223, 0x21e, 0x21a, 0x216, 0x212, 0x20e, 0x209,
    0x205, 0x201, 0x1fd, 0x1f9, 0x1f5, 0x1f0, 0x1ec, 0x1e8,
    0x1e4, 0x1e0, 0x1dc, 0x1d8, 0x1d4, 0x1d0, 0x1cc, 0x1c8,
    0x1c4, 0x1c0, 0x1bc, 0x1b8, 0x1b4, 0x1b0, 0x1ac, 0x1a8,
    0x1a4, 0x1a0, 0x19c, 0x199, 0x195, 0x191, 0x18d, 0x189,
    0x185, 0x181, 0x17e, 0x17a, 0x176, 0x172, 0x16f, 0x16b,
    0x167, 0x163, 0x160, 0x15c, 0x158, 0x154, 0x151, 0x14d,
    0x149, 0x146, 0x142, 0x13e, 0x13b, 0x137, 0x134, 0x130,
    0x12c, 0x129, 0x125, 0x122, 0x11e, 0x11b, 0x117, 0x114,
    0x110, 0x10c, 0x109, 0x106, 0x102, 0x0ff, 0x0fb, 0x0f8,
    0x0f4, 0x0f1, 0x0ed, 0x0ea, 0x0e7, 0x0e3, 0x0e0, 0x0dc,
    0x0d9, 0x0d6, 0x0d2, 0x0cf, 0x0cc, 0x0c8, 0x0c5, 0x0c2,
    0x0be, 0x0bb, 0x0b8, 0x0b5, 0x0b1, 0x0ae, 0x0ab, 0x0a8,
    0x0a4, 0x0a1, 0x09e, 0x09b, 0x098, 0x094, 0x091, 0x08e,
    0x08b, 0x088, 0x085, 0x082, 0x07e, 0x07b, 0x078, 0x075,
    0x072, 0x06f, 0x06c, 0x069, 0x066, 0x063, 0x060, 0x05d,
    0x05a, 0x057, 0x054, 0x051, 0x04e, 0x04b, 0x048, 0x045,
    0x042, 0x03f, 0x03c, 0x039, 0x036, 0x033, 0x030, 0x02d,
    0x02a, 0x028, 0x025, 0x022, 0x01f, 0x01c, 0x019, 0x016,
    0x014, 0x011, 0x00e, 0x00b, 0x008, 0x006, 0x003, 0x000};

static const uint8_t lut_pan_l[128] = {
    0x00, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
    0xfe, 0xfd, 0xfd, 0xfd, 0xfc, 0xfc, 0xfb, 0xfb,
    0xfa, 0xf9, 0xf9, 0xf8, 0xf7, 0xf7, 0xf6, 0xf5,
    0xf4, 0xf3, 0xf2, 0xf1, 0xf0, 0xef, 0xee, 0xed,
    0xec, 0xea, 0xe9, 0xe8, 0xe7, 0xe5, 0xe4, 0xe2,
    0xe1, 0xdf, 0xde, 0xdc, 0xdb, 0xd9, 0xd7, 0xd6,
    0xd4, 0xd2, 0xd0, 0xcf, 0xcd, 0xcb, 0xc9, 0xc7,
    0xc5, 0xc3, 0xc1, 0xbf, 0xbd, 0xba, 0xb8, 0xb6,
    0xb4, 0xb2, 0xaf, 0xad, 0xab, 0xa8, 0xa6, 0xa3,
    0xa1, 0x9e, 0x9c, 0x99, 0x97, 0x94, 0x92, 0x8f,
    0x8d, 0x8a, 0x87, 0x84, 0x82, 0x7f, 0x7c, 0x79,
    0x77, 0x74, 0x71, 0x6e, 0x6b, 0x68, 0x65, 0x63,
    0x60, 0x5d, 0x5a, 0x57, 0x54, 0x51, 0x4e, 0x4b,
    0x48, 0x45, 0x41, 0x3e, 0x3b, 0x38, 0x35, 0x32,
    0x2f, 0x2c, 0x29, 0x26, 0x22, 0x1f, 0x1c, 0x19,
    0x16, 0x13, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x00};

static const uint8_t lut_pan_r[128] = {
    0x00, 0x00, 0x03, 0x06, 0x09, 0x0c, 0x0f, 0x13,
    0x16, 0x19, 0x1c, 0x1f, 0x22, 0x26, 0x29, 0x2c,
    0x2f, 0x32, 0x35, 0x38, 0x3b, 0x3e, 0x41, 0x45,
    0x48, 0x4b, 0x4e, 0x51, 0x54, 0x57, 0x5a, 0x5d,
    0x60, 0x63, 0x65, 0x68, 0x6b, 0x6e, 0x71, 0x74,
    0x77, 0x79, 0x7c, 0x7f, 0x82, 0x84, 0x87, 0x8a,
    0x8d, 0x8f, 0x92, 0x94, 0x97, 0x99, 0x9c, 0x9e,
    0xa1, 0xa3, 0xa6, 0xa8, 0xab, 0xad, 0xaf, 0xb2,
    0xb4, 0xb6, 0xb8, 0xba, 0xbd, 0xbf, 0xc1, 0xc3,
    0xc5, 0xc7, 0xc9, 0xcb, 0xcd, 0xcf, 0xd0, 0xd2,
    0xd4, 0xd6, 0xd7, 0xd9, 0xdb, 0xdc, 0xde, 0xdf,
    0xe1, 0xe2, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea,
    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf9, 0xf9,
    0xfa, 0xfb, 0xfb, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd,
    0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff};

static const uint8_t mult_lut[16] = {1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30};
static const uint8_t ksl_lut[16]  = {0, 32, 40, 45, 48, 51, 53, 55, 56, 58, 59, 60, 61, 62, 63, 64};

Aq32Audio::Aq32Audio() {
    reset();
}

void Aq32Audio::reset() {
    reg0_ch_4op = 0;
    reg1        = 0;
    reg2_kon    = 0;
    memset(ch_attr, 0, sizeof(ch_attr));
    memset(op_attr0, 0, sizeof(op_attr0));
    memset(op_attr1, 0, sizeof(op_attr1));
    memset(chData, 0, sizeof(chData));
    memset(opData, 0, sizeof(opData));
    timer  = 0;
    vibpos = 0;
    am_dir = false;
    am_cnt = 0;

    for (unsigned i = 0; i < 64; i++) {
        opData[i].eg_env   = 0x1FF;
        opData[i].eg_stage = EG_RELEASE;
    }
}

void Aq32Audio::render(int16_t results[2]) {
    bool dam = (reg1 >> 7) & 1;
    bool dvb = (reg1 >> 6) & 1;

    int accum_l   = 0;
    int accum_r   = 0;
    int op_result = 0;

    // AM / Vibrato
    timer = (timer + 1) & 0x3FF;
    if (timer == 0x3FF)
        vibpos = (vibpos + 1) & 7;
    if ((timer & 0x3F) == 0x3F) {
        am_cnt += am_dir ? 0xFF : 0x01;
        if (am_cnt == 105)
            am_dir = true;
        else if (am_cnt == 0)
            am_dir = false;
    }
    unsigned am_val = am_cnt >> (dam ? 2 : 4);

    for (unsigned op_sel = 0; op_sel < 64; op_sel++) {
        unsigned ws   = (op_attr1[op_sel] >> 0) & 7;
        bool     am   = (op_attr0[op_sel] >> 31) & 1;
        bool     vib  = (op_attr0[op_sel] >> 30) & 1;
        bool     sus  = (op_attr0[op_sel] >> 29) & 1;
        bool     ksr  = (op_attr0[op_sel] >> 28) & 1;
        unsigned mult = mult_lut[(op_attr0[op_sel] >> 24) & 0xF];
        unsigned ksl  = (op_attr0[op_sel] >> 22) & 3;
        unsigned tl   = (op_attr0[op_sel] >> 16) & 0x3F;
        unsigned ar   = (op_attr0[op_sel] >> 12) & 0xF;
        unsigned dr   = (op_attr0[op_sel] >> 8) & 0xF;
        unsigned sl   = (op_attr0[op_sel] >> 4) & 0xF;
        unsigned rr   = (op_attr0[op_sel] >> 0) & 0xF;
        OpData  &opd  = opData[op_sel];

        if (sl == 0xF)
            sl = 0x1F;

        unsigned pan     = (ch_attr[op_sel / 2] >> 20) & 127;
        unsigned fb      = (ch_attr[op_sel / 2] >> 17) & 7;
        bool     alg_2op = (ch_attr[op_sel / 2] >> 16) & 1;
        unsigned alg_4op = (((ch_attr[(op_sel / 4) * 2 + 0] >> 16) & 1) << 1) | ((ch_attr[(op_sel / 4) * 2 + 1] >> 16) & 1);
        unsigned block   = (ch_attr[op_sel / 2] >> 10) & 7;
        unsigned fnum    = (ch_attr[op_sel / 2] >> 0) & 0x3FF;
        bool     is_4op  = (reg0_ch_4op >> (op_sel / 4)) & 1;
        bool     kon     = (reg2_kon >> (op_sel / 2)) & 1;
        ChData  &chd     = chData[op_sel / 2];

        // Sample rate of audio is compatible with OPL (being 49722Hz),
        // but emulator has a sample rate of 44100Hz.
        // So we scale the frequency numbers here:
        fnum = (fnum * 49722) / 44100;
        if (fnum > 0x3FF) {
            fnum = 0x3FF;
        }

        bool do_fb;
        bool do_sum;
        bool do_mod;

        if (!is_4op) {
            do_fb  = (op_sel & 1) == 0;
            do_sum = (op_sel & 1) != 0 || alg_2op;
            do_mod = !alg_2op;

        } else {
            do_fb = (op_sel & 3) == 0;

            switch (alg_4op) {
                case 0: do_sum = (op_sel & 3) == 3; break;
                case 1: do_sum = (op_sel & 1) != 0; break;
                case 2: do_sum = !(((op_sel >> 1) & 1) ^ (op_sel & 1)); break;
                case 3: do_sum = (op_sel & 3) != 1; break;
            }
            switch (alg_4op) {
                case 0: do_mod = true; break;
                case 1: do_mod = (op_sel & 1) != 0; break;
                case 2: do_mod = (op_sel & 2) != 0; break;
                case 3: do_mod = (op_sel & 3) == 2; break;
            }
        }

        // EG
        unsigned env;
        bool     restart = false;
        {
            int eg_ksl = (ksl_lut[(fnum >> 6) & 0xF] << 2) - ((8 - block) << 5);
            if (eg_ksl < 0)
                eg_ksl = 0;

            switch (ksl) {
                case 0: eg_ksl >>= 8; break;
                case 1: eg_ksl >>= 1; break;
                case 2: eg_ksl >>= 2; break;
                case 3: eg_ksl >>= 0; break;
            }
            env = std::min(511U, opd.eg_env + (tl << 2) + eg_ksl + (am ? am_val : 0));

            // Rate offset (based on key split and key scaling)
            unsigned rof = ((block << 1) | ((fnum >> 9) & 1)) >> (ksr ? 0 : 2);

            // Stage rate
            unsigned stage_rate = 0;
            if (kon && opd.eg_stage == EG_RELEASE) {
                restart    = true;
                stage_rate = ar;

            } else {
                switch (opd.eg_stage) {
                    case EG_ATTACK: stage_rate = ar; break;
                    case EG_DECAY: stage_rate = dr; break;
                    case EG_SUSTAIN: stage_rate = sus ? 0 : rr; break;
                    case EG_RELEASE: stage_rate = rr; break;
                }
            }

            unsigned rate = std::min(63U, rof + (stage_rate << 2));

            uint8_t overflow = 0;
            if (stage_rate != 0) {
                unsigned eg_cnt = opd.eg_cnt + ((4 | (rate & 3)) << ((rate >> 2) & 0xF));
                overflow        = eg_cnt >> 15;
                opd.eg_cnt      = eg_cnt & 0x7FFF;
            }

            switch (opd.eg_stage) {
                case EG_ATTACK: {
                    if (opd.eg_env == 0)
                        opd.eg_stage = EG_DECAY;
                    else if (overflow > 0)
                        opd.eg_env -= ((opd.eg_env * overflow) >> 3) + 1;
                    break;
                }
                case EG_DECAY: {
                    if ((opd.eg_env >> 4U) >= sl) {
                        opd.eg_stage = EG_SUSTAIN;
                    } else {
                        opd.eg_env = std::min(511, opd.eg_env + overflow);
                    }
                    break;
                }
                case EG_SUSTAIN:
                case EG_RELEASE: {
                    opd.eg_env = std::min(511, opd.eg_env + overflow);
                    break;
                }
            }

            if (restart)
                opd.eg_stage = EG_ATTACK;
            if (!kon)
                opd.eg_stage = EG_RELEASE;
        }

        // Phase
        unsigned phase;
        {
            // Phase: Vibrato
            unsigned range = (fnum >> 7) & 7;
            if ((vibpos & 3) == 0 || !vib)
                range = 0;
            else if (vibpos & 1)
                range >>= 1;
            if (!dvb)
                range >>= 1;
            unsigned f_num = (vibpos & 4) ? (fnum - range) : (fnum + range);

            // Phase: Accumulator
            unsigned phase_inc = (((f_num << block) >> 1) * mult) >> 1;
            phase              = opd.phase >> 9;
            opd.phase          = (restart ? 0 : opd.phase) + phase_inc;
        }

        // Feedback
        int fbmod = (fb == 0) ? 0 : (((chd.prevSamples[0] + chd.prevSamples[1]) / 4) >> (fb ^ 7));

        // Operator
        {
            unsigned op_modulation = 0;
            if (do_fb)
                op_modulation = fbmod;
            else if (do_mod)
                op_modulation = op_result;

            unsigned op_phase = (phase + op_modulation) & 0x3FF;

            uint8_t logsin_idx;
            switch (ws) {
                default: logsin_idx = ((op_phase & 0x100) ? ~op_phase : op_phase) & 0xFF; break;
                case 4:
                case 5: logsin_idx = (((op_phase & 0x100) ? ~op_phase : op_phase) << 1) & 0xFF; break;
            }
            unsigned logsin_value = lut_logsin[logsin_idx];

            bool negate;
            switch (ws) {
                default: negate = false; break;
                case 0:
                case 6:
                case 7: negate = (op_phase & 0x200) != 0; break;
                case 4: negate = (op_phase & 0x300) == 0x100; break;
            }

            unsigned out;
            switch (ws) {
                default: out = logsin_value; break;
                case 1:
                case 4:
                case 5: out = (op_phase & 0x200) ? 0x1000 : logsin_value; break;
                case 3: out = (op_phase & 0x100) ? 0x1000 : logsin_value; break;
                case 6: out = 0; break;
                case 7: out = ((op_phase & 0x1FF) ^ ((op_phase & 0x200) ? 0x1FF : 0)) << 3; break;
            }

            unsigned level = std::min(0x1FFFU, out + (env << 3));
            op_result      = ((0x400 | lut_exp[level & 0xFF]) << 1) >> (level >> 8);
            if (op_result != 0 && negate)
                op_result = ~op_result;

            if (do_sum) {
                accum_l += (op_result * lut_pan_l[pan]) >> 8;
                accum_r += (op_result * lut_pan_r[pan]) >> 8;
            }

            if ((op_sel & 1) == 0) {
                chd.prevSamples[1] = chd.prevSamples[0];
                chd.prevSamples[0] = op_result;
            }
        }
    }

    results[0] = std::min(std::max(-32768, accum_l), 32767);
    results[1] = std::min(std::max(-32768, accum_r), 32767);
}

void Aq32Audio::dbgDrawIoRegs() {
    ImGui::Text("reg0_ch_4op: 0x%04X", reg0_ch_4op);
    ImGui::Text("reg1: 0x%04X", reg1);
    ImGui::Text("reg2_kon: 0x%08X", reg2_kon);
}
